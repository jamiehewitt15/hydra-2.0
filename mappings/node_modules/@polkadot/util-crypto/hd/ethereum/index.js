"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hdEthereum = hdEthereum;
exports.HDKey = void 0;

var _util = require("@polkadot/util");

var _hmac = require("../../hmac");

var _secp256k = require("../../secp256k1");

var _validatePath = require("../validatePath");

// Copyright 2017-2021 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
const MASTER_SECRET = (0, _util.stringToU8a)('Bitcoin seed');

class HDKey {
  constructor(secretKey, chainCode) {
    this.chainCode = void 0;
    this.publicKey = void 0;
    this.secretKey = void 0;
    this.secretKey = secretKey;
    this.publicKey = (0, _secp256k.secp256k1KeypairFromSeed)(secretKey).publicKey;
    this.chainCode = chainCode;
  }

  derive(path) {
    if (path === 'm' || path === 'M' || path === "m'" || path === "M'") {
      return this;
    }

    (0, _util.assert)((0, _validatePath.hdValidatePath)(path), 'Invalid derivation path');
    return path.split('/').slice(1).reduce((hd, c) => hd.deriveChild(parseInt(c, 10) + (c.length > 1 && c.endsWith("'") ? _validatePath.HARDENED : 0)), this);
  }

  deriveChild(index) {
    const indexBuffer = (0, _util.bnToU8a)(index, {
      bitLength: 32,
      isLe: false
    });
    const data = index >= _validatePath.HARDENED ? (0, _util.u8aConcat)(new Uint8Array(1), this.secretKey, indexBuffer) : (0, _util.u8aConcat)(this.publicKey, indexBuffer);

    try {
      const I = (0, _hmac.hmacSha512)(this.chainCode, data);
      return new HDKey((0, _secp256k.secp256k1PrivateKeyTweakAdd)(this.secretKey, I.slice(0, 32)), I.slice(32));
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, proceed with the next value for i
      return this.deriveChild(index + 1);
    }
  }

}

exports.HDKey = HDKey;

function hdEthereum(seed, path = '') {
  const I = (0, _hmac.hmacSha512)(MASTER_SECRET, seed);
  const hdkey = new HDKey(I.slice(0, 32), I.slice(32));
  const {
    publicKey,
    secretKey
  } = path ? hdkey.derive(path) : hdkey;
  return {
    publicKey,
    secretKey
  };
}