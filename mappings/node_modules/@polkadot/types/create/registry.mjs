import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _classPrivateFieldLooseBase from "@babel/runtime/helpers/esm/classPrivateFieldLooseBase";
import _classPrivateFieldLooseKey from "@babel/runtime/helpers/esm/classPrivateFieldLooseKey";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0

/* eslint-disable @typescript-eslint/no-var-requires */
// we are attempting to avoid circular refs, hence the Metadata path import
import { extrinsicsFromMeta } from '@polkadot/metadata/decorate/extrinsics/fromMetadata';
import { Metadata } from '@polkadot/metadata/Metadata';
import { assert, assertReturn, BN_ZERO, formatBalance, isFunction, isString, isU8a, logger, stringCamelCase, u8aToHex } from '@polkadot/util';
import { blake2AsU8a } from '@polkadot/util-crypto';
import { Json } from "../codec/Json.mjs";
import { Raw } from "../codec/Raw.mjs";
import { defaultExtensions, expandExtensionTypes, findUnknownExtensions } from "../extrinsic/signedExtensions/index.mjs";
import { GenericEventData } from "../generic/Event.mjs";
import * as baseTypes from "../index.types.mjs";
import * as definitions from "../interfaces/definitions.mjs";
import { DoNotConstruct } from "../primitive/DoNotConstruct.mjs";
import { createClass, getTypeClass } from "./createClass.mjs";
import { createType } from "./createType.mjs";
import { getTypeDef } from "./getTypeDef.mjs";
const l = logger('registry'); // create error mapping from metadata

function decorateErrors(_, metadata, metadataErrors) {
  const modules = metadata.asLatest.modules;
  const isIndexed = modules.some(({
    index
  }) => !index.eqn(255)); // decorate the errors

  modules.forEach((section, _sectionIndex) => {
    const sectionIndex = isIndexed ? section.index.toNumber() : _sectionIndex;
    const sectionName = stringCamelCase(section.name);
    section.errors.forEach(({
      documentation,
      name
    }, index) => {
      const eventIndex = new Uint8Array([sectionIndex, index]);
      metadataErrors[u8aToHex(eventIndex)] = {
        documentation: documentation.map(d => d.toString()),
        index,
        name: name.toString(),
        section: sectionName
      };
    });
  });
} // create event classes from metadata


function decorateEvents(registry, metadata, metadataEvents) {
  const modules = metadata.asLatest.modules;
  const isIndexed = modules.some(({
    index
  }) => !index.eqn(255)); // decorate the events

  modules.filter(({
    events
  }) => events.isSome).forEach((section, _sectionIndex) => {
    const sectionIndex = isIndexed ? section.index.toNumber() : _sectionIndex;
    const sectionName = stringCamelCase(section.name);
    section.events.unwrap().forEach((meta, methodIndex) => {
      const methodName = meta.name.toString();
      const eventIndex = new Uint8Array([sectionIndex, methodIndex]); // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access

      const typeDef = meta.args.map(arg => getTypeDef(arg));
      let Types = [];

      try {
        Types = typeDef.map(typeDef => getTypeClass(registry, typeDef));
      } catch (error) {
        l.error(error);
      }

      metadataEvents[u8aToHex(eventIndex)] = class extends GenericEventData {
        constructor(registry, value) {
          super(registry, value, Types, typeDef, meta, sectionName, methodName);
        }

      };
    });
  });
} // create extrinsic mapping from metadata


function decorateExtrinsics(registry, metadata, metadataCalls) {
  const extrinsics = extrinsicsFromMeta(registry, metadata); // decorate the extrinsics

  Object.values(extrinsics).forEach(methods => Object.values(methods).forEach(method => {
    metadataCalls[u8aToHex(method.callIndex)] = method;
  }));
}

var _classes = _classPrivateFieldLooseKey("classes");

var _definitions = _classPrivateFieldLooseKey("definitions");

var _metadataCalls = _classPrivateFieldLooseKey("metadataCalls");

var _metadataErrors = _classPrivateFieldLooseKey("metadataErrors");

var _metadataEvents = _classPrivateFieldLooseKey("metadataEvents");

var _unknownTypes = _classPrivateFieldLooseKey("unknownTypes");

var _chainProperties = _classPrivateFieldLooseKey("chainProperties");

var _hasher = _classPrivateFieldLooseKey("hasher");

var _knownDefaults = _classPrivateFieldLooseKey("knownDefaults");

var _knownDefinitions = _classPrivateFieldLooseKey("knownDefinitions");

var _knownTypes = _classPrivateFieldLooseKey("knownTypes");

var _signedExtensions = _classPrivateFieldLooseKey("signedExtensions");

export class TypeRegistry {
  constructor() {
    Object.defineProperty(this, _classes, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _definitions, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _metadataCalls, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _metadataErrors, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _metadataEvents, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _unknownTypes, {
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, _chainProperties, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _hasher, {
      writable: true,
      value: blake2AsU8a
    });
    Object.defineProperty(this, _knownDefaults, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _knownDefinitions, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _knownTypes, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _signedExtensions, {
      writable: true,
      value: defaultExtensions
    });
    _classPrivateFieldLooseBase(this, _knownDefaults)[_knownDefaults] = _objectSpread({
      Json,
      Metadata,
      Raw
    }, baseTypes);
    _classPrivateFieldLooseBase(this, _knownDefinitions)[_knownDefinitions] = definitions;
    this.init();
  }

  init() {
    // start clean
    _classPrivateFieldLooseBase(this, _classes)[_classes] = new Map();
    _classPrivateFieldLooseBase(this, _definitions)[_definitions] = new Map();
    _classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes] = new Map();
    _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes] = {}; // register know, first classes then on-demand-created definitions

    this.register(_classPrivateFieldLooseBase(this, _knownDefaults)[_knownDefaults]);
    Object.values(_classPrivateFieldLooseBase(this, _knownDefinitions)[_knownDefinitions]).forEach(({
      types
    }) => this.register(types));
    return this;
  }

  get chainDecimals() {
    var _classPrivateFieldLoo;

    return (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo !== void 0 && _classPrivateFieldLoo.tokenDecimals.isSome ? _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].tokenDecimals.unwrap().toNumber() : 12;
  }

  get chainSS58() {
    var _classPrivateFieldLoo2;

    return (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo2 !== void 0 && _classPrivateFieldLoo2.ss58Format.isSome ? _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].ss58Format.unwrap().toNumber() : undefined;
  }

  get chainToken() {
    var _classPrivateFieldLoo3;

    return (_classPrivateFieldLoo3 = _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo3 !== void 0 && _classPrivateFieldLoo3.tokenSymbol.isSome ? _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties].tokenSymbol.unwrap().toString() : formatBalance.getDefaults().unit;
  }

  get knownTypes() {
    return _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes];
  }

  get signedExtensions() {
    return _classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions];
  }
  /**
   * @describe Creates an instance of the class
   */


  createClass(type) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return createClass(this, type);
  }
  /**
   * @description Creates an instance of a type as registered
   */


  createType(type, ...params) {
    return createType(this, type, ...params);
  } // find a specific call


  findMetaCall(callIndex) {
    const hexIndex = u8aToHex(callIndex);
    return assertReturn(_classPrivateFieldLooseBase(this, _metadataCalls)[_metadataCalls][hexIndex], `findMetaCall: Unable to find Call with index ${hexIndex}/[${callIndex.toString()}]`);
  } // finds an error


  findMetaError(errorIndex) {
    const hexIndex = u8aToHex(isU8a(errorIndex) ? errorIndex : new Uint8Array([errorIndex.index.toNumber(), errorIndex.error.toNumber()]));
    return assertReturn(_classPrivateFieldLooseBase(this, _metadataErrors)[_metadataErrors][hexIndex], `findMetaError: Unable to find Error with index ${hexIndex}/[${errorIndex.toString()}]`);
  }

  findMetaEvent(eventIndex) {
    const hexIndex = u8aToHex(eventIndex);
    return assertReturn(_classPrivateFieldLooseBase(this, _metadataEvents)[_metadataEvents][hexIndex], `findMetaEvent: Unable to find Event with index ${hexIndex}/[${eventIndex.toString()}]`);
  }

  get(name, withUnknown) {
    let Type = _classPrivateFieldLooseBase(this, _classes)[_classes].get(name); // we have not already created the type, attempt it


    if (!Type) {
      const definition = _classPrivateFieldLooseBase(this, _definitions)[_definitions].get(name);

      let BaseType; // we have a definition, so create the class now (lazily)

      if (definition) {
        BaseType = createClass(this, definition);
      } else if (withUnknown) {
        l.warn(`Unable to resolve type ${name}, it will fail on construction`);

        _classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].set(name, true);

        BaseType = DoNotConstruct.with(name);
      }

      if (BaseType) {
        // NOTE If we didn't extend here, we would have strange artifacts. An example is
        // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128
        // Additionally, we now pass through the registry, which is a link to ourselves
        Type = class extends BaseType {};

        _classPrivateFieldLooseBase(this, _classes)[_classes].set(name, Type);
      }
    }

    return Type;
  }

  getChainProperties() {
    return _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties];
  }

  getClassName(clazz) {
    const entry = [..._classPrivateFieldLooseBase(this, _classes)[_classes].entries()].find(([, test]) => test === clazz);
    return entry ? entry[0] : undefined;
  }

  getDefinition(name) {
    return _classPrivateFieldLooseBase(this, _definitions)[_definitions].get(name);
  }

  getOrThrow(name, msg) {
    return assertReturn(this.get(name), msg || `type ${name} not found`);
  }

  getOrUnknown(name) {
    return this.get(name, true);
  }

  getSignedExtensionExtra() {
    return expandExtensionTypes(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], 'extra');
  }

  getSignedExtensionTypes() {
    return expandExtensionTypes(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions], 'types');
  }

  hasClass(name) {
    return _classPrivateFieldLooseBase(this, _classes)[_classes].has(name);
  }

  hasDef(name) {
    return _classPrivateFieldLooseBase(this, _definitions)[_definitions].has(name);
  }

  hasType(name) {
    return !_classPrivateFieldLooseBase(this, _unknownTypes)[_unknownTypes].get(name) && (this.hasClass(name) || this.hasDef(name));
  }

  hash(data) {
    return this.createType('H256', _classPrivateFieldLooseBase(this, _hasher)[_hasher](data));
  }

  // eslint-disable-next-line no-dupe-class-members
  register(arg1, arg2) {
    // NOTE Constructors appear as functions here
    if (isFunction(arg1)) {
      _classPrivateFieldLooseBase(this, _classes)[_classes].set(arg1.name, arg1);
    } else if (isString(arg1)) {
      assert(isFunction(arg2), `Expected class definition passed to '${arg1}' registration`);

      _classPrivateFieldLooseBase(this, _classes)[_classes].set(arg1, arg2);
    } else {
      this._registerObject(arg1);
    }
  }

  _registerObject(obj) {
    Object.entries(obj).forEach(([name, type]) => {
      if (isFunction(type)) {
        // This _looks_ a bit funny, but `typeof Clazz === 'function'
        _classPrivateFieldLooseBase(this, _classes)[_classes].set(name, type);
      } else {
        const def = isString(type) ? type : JSON.stringify(type); // we already have this type, remove the classes registered for it

        if (_classPrivateFieldLooseBase(this, _classes)[_classes].has(name)) {
          _classPrivateFieldLooseBase(this, _classes)[_classes].delete(name);
        }

        _classPrivateFieldLooseBase(this, _definitions)[_definitions].set(name, def);
      }
    });
  } // sets the chain properties


  setChainProperties(properties) {
    if (properties) {
      _classPrivateFieldLooseBase(this, _chainProperties)[_chainProperties] = properties;
    }
  }

  setHasher(hasher = blake2AsU8a) {
    _classPrivateFieldLooseBase(this, _hasher)[_hasher] = hasher;
  }

  setKnownTypes(knownTypes) {
    _classPrivateFieldLooseBase(this, _knownTypes)[_knownTypes] = knownTypes;
  } // sets the metadata


  setMetadata(metadata, signedExtensions) {
    decorateExtrinsics(this, metadata, _classPrivateFieldLooseBase(this, _metadataCalls)[_metadataCalls]);
    decorateErrors(this, metadata, _classPrivateFieldLooseBase(this, _metadataErrors)[_metadataErrors]);
    decorateEvents(this, metadata, _classPrivateFieldLooseBase(this, _metadataEvents)[_metadataEvents]); // setup the available extensions

    this.setSignedExtensions(signedExtensions || (metadata.asLatest.extrinsic.version.gt(BN_ZERO) ? metadata.asLatest.extrinsic.signedExtensions.map(key => key.toString()) : defaultExtensions));
  } // sets the available signed extensions


  setSignedExtensions(signedExtensions = defaultExtensions) {
    _classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions] = signedExtensions;
    const unknown = findUnknownExtensions(_classPrivateFieldLooseBase(this, _signedExtensions)[_signedExtensions]);

    if (unknown.length) {
      l.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);
    }
  }

}