"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stripTypes = exports.extractMeta = void 0;
const metadata_1 = require("./metadata");
const lodash_1 = require("lodash");
const types_1 = require("./types");
const util_1 = require("../util");
const default_types_1 = require("./default-types");
const debug = require('debug')('hydra-typegen:extract');
async function extractMeta({ metadata: metadataSource, events, calls, }) {
    const modules = {};
    const moduleEvents = {};
    const moduleCalls = {};
    const moduleTypes = {};
    const metadata = await metadata_1.getMetadata(metadataSource);
    for (const e of events) {
        const [module, event] = findEvent(metadata, e);
        const name = module.name.toString();
        modules[name] = module;
        util_1.pushToDictionary(moduleEvents, name, event);
        util_1.pushToDictionary(moduleTypes, name, ...stripTypes(event.args));
    }
    for (const c of calls) {
        const [module, call] = findCall(metadata, c);
        const name = module.name.toString();
        modules[name] = module;
        util_1.pushToDictionary(moduleCalls, name, call);
        util_1.pushToDictionary(moduleTypes, name, ...stripTypes(call.args.map((a) => a.type.toString())));
    }
    return Object.keys(modules).map((name) => ({
        module: modules[name],
        events: moduleEvents[name],
        calls: moduleCalls[name],
        types: moduleTypes[name],
    }));
}
exports.extractMeta = extractMeta;
function findCall(metadata, callName) {
    const [moduleName, method] = callName.split('.');
    const module = metadata.modules.find((v) => types_1.weakEquals(v.name, moduleName));
    if (module === undefined || module.calls === undefined) {
        throw new Error(`No metadata found for module ${moduleName}`);
    }
    const call = module.calls
        .unwrapOr([])
        .find((c) => types_1.weakEquals(c.name, method));
    if (call === undefined) {
        throw new Error(`No metadata found for the call ${callName}`);
    }
    validateTypes(call.args.map((arg) => arg.type));
    return [module, call];
}
function findEvent(metadata, eventName) {
    const [moduleName, method] = eventName.split('.');
    const module = metadata.modules.find((v) => types_1.weakEquals(v.name, moduleName));
    if (module === undefined || module.events === undefined) {
        throw new Error(`No metadata found for module ${moduleName}`);
    }
    const event = module.events
        .unwrapOr([])
        .find((e) => types_1.weakEquals(e.name, method));
    if (event === undefined) {
        throw new Error(`No metadata found for the event ${eventName}`);
    }
    validateTypes(event.args);
    return [module, event];
}
function validateTypes(argTypes) {
    const stripped = stripTypes(argTypes);
    for (const t of stripped) {
        if (!default_types_1.builtInClasses.includes(t) && !metadata_1.registry.hasType(t)) {
            throw new Error(`Cannot find a type defintion for ${t}. Make sure it is included in the type definition file`);
        }
    }
    debug(`Validated types: ${stripTypes(argTypes).join(',')}`);
}
/**
 * Reduce all argument types to single types, e.g. Compact<Balance> to [Compact, Balance]
 *
 * @param e event
 */
function stripTypes(argTypes) {
    const types = [];
    argTypes.forEach((a) => {
        const type = a.toString().trim();
        if (type.includes('<') || type.includes('&') || type.includes('|')) {
            types.push(...type.split(/[<>&|]/).map((t) => t.trim()));
        }
        else {
            types.push(type);
        }
    });
    return lodash_1.compact(lodash_1.uniq(types));
}
exports.stripTypes = stripTypes;
