"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerCustomTypes = exports.getMetadata = exports.registry = void 0;
const tslib_1 = require("tslib");
const metadata_1 = require("@polkadot/metadata");
const create_1 = require("@polkadot/types/create");
const x_ws_1 = tslib_1.__importDefault(require("@polkadot/x-ws"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("../util");
const debug = require('debug')('hydra-typegen:metadata');
exports.registry = new create_1.TypeRegistry();
async function getMetadata({ source, blockHash, }) {
    let metaHex;
    debug(`Reading metadata: from ${source}`);
    if (source.startsWith('wss://') || source.startsWith('ws://')) {
        debug(`Reading from chain: ${source}`);
        metaHex = await fromChain(source, blockHash);
    }
    else {
        metaHex = require(path_1.default.join(process.cwd(), source)).result;
    }
    const meta = new metadata_1.Metadata(exports.registry, metaHex);
    exports.registry.setMetadata(meta);
    return meta.asLatest;
}
exports.getMetadata = getMetadata;
function registerCustomTypes(typeDefs) {
    const typeDefsJson = util_1.readJson(typeDefs);
    exports.registry.register(typeDefsJson);
    debug(`Registered ${Object.keys(typeDefsJson).join(',')}`);
    return typeDefsJson;
}
exports.registerCustomTypes = registerCustomTypes;
// export function registerTypes(custom: CustomTypes = {}, spec?: ChainSpec) {
//   registry.setKnownTypes({ types: custom })
//   if (spec) {
//     registry.register(
//       getSpecTypes(registry, spec.chain, spec.name, spec.version)
//     )
//   }
// }
async function fromChain(endpoint, blockHash) {
    const blockHashParam = blockHash ? `"${blockHash}"` : '';
    return new Promise((resolve, reject) => {
        try {
            const websocket = new x_ws_1.default(endpoint);
            websocket.onclose = (event) => {
                reject(new Error(`disconnected, code: '${event.code}' reason: '${event.reason}'`));
            };
            websocket.onerror = (event) => {
                reject(new Error(JSON.stringify(event, null, 2)));
            };
            websocket.onopen = () => {
                debug('connected');
                // TODO: support chain height
                websocket.send(`{"id":"1","jsonrpc":"2.0","method":"state_getMetadata","params":[${blockHashParam}]}`);
            };
            websocket.onmessage = (message) => {
                const data = JSON.parse(message.data);
                if (data.error) {
                    reject(new Error(`RPC error: ${JSON.stringify(data.error, null, 2)}`));
                }
                else {
                    resolve(data.result);
                }
                websocket.close();
            };
        }
        catch (e) {
            reject(new Error(`Cannot fetch metadata: ${e.message}, ${JSON.stringify(e, null, 2)}`));
        }
    });
}
