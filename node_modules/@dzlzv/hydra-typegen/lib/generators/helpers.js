"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nameFromType = exports.inferName = exports.renderTypeOnlyArgs = exports.renderNamedArgs = exports.renderImports = exports.handlebars = void 0;
const tslib_1 = require("tslib");
const handlebars_1 = tslib_1.__importDefault(require("handlebars"));
const lodash_1 = require("lodash");
const log_1 = require("../log");
const debug = require('debug')('hydra-typegen:helpers');
exports.handlebars = handlebars_1.default.create();
const callArgValueGetter = (ctxIndex) => `[this.extrinsic.args[${ctxIndex}].value]`;
const eventParamValueGetter = (ctxIndex) => `[this.ctx.params[${ctxIndex}].value]`;
exports.handlebars.registerHelper({
    imports() {
        const { imports } = this;
        return renderImports(imports);
    },
    kebabCase(s) {
        return lodash_1.kebabCase(s);
    },
    camelCase(s) {
        return lodash_1.camelCase(s);
    },
    pascalCase(s) {
        return lodash_1.upperFirst(lodash_1.camelCase(s));
    },
    toString(s) {
        if (s.toString !== undefined) {
            return s.toString();
        }
        return JSON.stringify(s);
    },
    getters() {
        const { args } = this;
        return isNamedArgs(args)
            ? renderNamedArgs(args, callArgValueGetter)
            : renderTypeOnlyArgs(args, eventParamValueGetter);
    },
});
function isNamedArgs(args) {
    if (args.length === 0) {
        log_1.warn(`WARNING: empty arguments list`);
        return true;
    }
    return 'name' in args[0];
}
function renderImports(imports) {
    const defs = Object.keys(imports).map((loc) => ({
        file: loc,
        types: Object.keys(imports[loc]),
    }));
    debug(`Defs: ${JSON.stringify(defs, null, 2)}`);
    return defs.reduce((result, { file, types }) => {
        const typeImport = types && types.length
            ? `import { ${types.sort().join(', ')} } from '${file}';\n`
            : '';
        return `${result}${typeImport}`;
    }, '');
}
exports.renderImports = renderImports;
function renderNamedArgs(args, ctxValueGetter) {
    debug(`Rendering named args: ${JSON.stringify(args, null, 2)}`);
    return args.reduce((result, arg, index) => {
        const type = arg.type.toString();
        const name = lodash_1.camelCase(arg.name.toString());
        const getStmt = 
        // prettier-ignore
        `get ${name}(): ${type} {
          return ${renderCreateTypeStmt(type, ctxValueGetter(index))}
       }`;
        return `${result}\n${getStmt}\n`;
    }, '');
}
exports.renderNamedArgs = renderNamedArgs;
function renderTypeOnlyArgs(argTypes, ctxValueGetter) {
    debug(`Rendering type only args: ${JSON.stringify(argTypes, null, 2)}`);
    const grouped = lodash_1.countBy(argTypes);
    const typeToIndices = {};
    argTypes.forEach((a, i) => {
        if (typeToIndices[a]) {
            typeToIndices[a].push(i);
        }
        else {
            typeToIndices[a] = [i];
        }
    });
    return argTypes.reduce((result, argType, index) => {
        let getStmt = '';
        if (grouped[argType] === 1) {
            getStmt = `get ${nameFromType(argType)}(): ${argType} {
        return ${renderCreateTypeStmt(argType, ctxValueGetter(index))}
      }`;
            // once we at the last index of that type
        }
        else if (index === lodash_1.last(typeToIndices[argType])) {
            getStmt =
                // prettier-ignore
                `get ${nameFromType(argType)}s(): { [key: number]: ${argType} } {
          return {
            ${renderCreateTypesArray(argType, typeToIndices[argType], ctxValueGetter)}
          }
        }`;
        }
        return `${result}\n${getStmt}\n`;
    }, '');
}
exports.renderTypeOnlyArgs = renderTypeOnlyArgs;
function renderCreateTypesArray(argType, indices, ctxValueGetter) {
    return indices.reduce((result, argIndex, i) => `${result}${i}: ${renderCreateTypeStmt(argType, ctxValueGetter(argIndex))},\n`, '');
}
function renderCreateTypeStmt(argType, ctxValueGetter) {
    return `createTypeUnsafe<${argType} & Codec>(
            typeRegistry, '${argType}', ${ctxValueGetter}) `;
}
function inferName(arg) {
    if (typeof arg === 'string') {
        return nameFromType(arg);
    }
    if (arg.name !== undefined) {
        return arg.name.toString();
    }
    return nameFromType(arg.type.toRawType());
}
exports.inferName = inferName;
function nameFromType(rawType) {
    let stripped = rawType.trim();
    if (stripped.includes('&')) {
        // if its a union type, take only the first part as it's
        // probably most descriptive
        stripped = stripped.split('&')[0].trim();
    }
    const match = /[^<]*<([^>]+)>.*/g.exec(stripped);
    if (match && match[1]) {
        stripped = match[1];
    }
    return lodash_1.camelCase(stripped);
}
exports.nameFromType = nameFromType;
