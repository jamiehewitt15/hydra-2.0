"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildImportsRegistry = void 0;
const log_1 = require("../log");
const default_types_1 = require("../metadata/default-types");
const metadata_1 = require("../metadata");
const debug = require('debug')('hydra-typegen:imports-registry');
const KNOWN_LOCATIONS = {
    interfaces: '@polkadot/types/interfaces',
    types: '@polkadot/types',
    typesTypes: '@polkadot/types/types',
    typesCreate: '@polkadot/types/create',
    metadata: '@polkadot/metadata',
    local: '.',
    hydraCommon: '@dzlzv/hydra-common',
};
const NO_CODEC = ['Tuple', 'VecFixed'];
const TYPES_TYPES = [
    'AnyNumber',
    'CallFunction',
    'Codec',
    'IExtrinsic',
    'ITuple',
];
const TYPES_CREATE = ['createTypeUnsafe', 'createType'];
const METADATA = ['Metadata'];
const LOCAL = ['typeRegistry'];
const HYDRA_COMMON = ['substrate'];
function buildImportsRegistry(customTypes) {
    const importsRegistry = {};
    // add primitive classes
    const typeClasses = default_types_1.builtInClasses.filter((name) => !NO_CODEC.includes(name));
    debug(`Built-in classes: ${typeClasses.join(',')}`);
    typeClasses.forEach((primitiveName) => {
        importsRegistry[primitiveName] = KNOWN_LOCATIONS.types;
    });
    for (const t of TYPES_TYPES) {
        importsRegistry[t] = KNOWN_LOCATIONS.typesTypes;
    }
    for (const t of TYPES_CREATE) {
        importsRegistry[t] = KNOWN_LOCATIONS.typesCreate;
    }
    for (const t of METADATA) {
        importsRegistry[t] = KNOWN_LOCATIONS.metadata;
    }
    for (const t of LOCAL) {
        importsRegistry[t] = KNOWN_LOCATIONS.local;
    }
    for (const t of HYDRA_COMMON) {
        importsRegistry[t] = KNOWN_LOCATIONS.hydraCommon;
    }
    addPolkadotInterfaces(importsRegistry);
    // this goes last so that it overrides all previous definitions
    if (customTypes) {
        addCustomTypes(importsRegistry, customTypes);
    }
    return importsRegistry;
}
exports.buildImportsRegistry = buildImportsRegistry;
function addPolkadotInterfaces(importsRegistry) {
    Object.entries(default_types_1.builtInInterfaceDefs).forEach(([, packageDef]) => {
        Object.keys(packageDef.types).forEach((type) => {
            if (importsRegistry[type]) {
                log_1.warn(`Overwriting duplicated type '${type}' ${importsRegistry[type]} -> ${KNOWN_LOCATIONS.interfaces}`);
            }
            importsRegistry[type] = KNOWN_LOCATIONS.interfaces;
        });
    });
}
function addCustomTypes(importsRegistry, customTypes) {
    const { lib, typedefsLoc } = customTypes;
    const defs = metadata_1.registerCustomTypes(typedefsLoc);
    Object.keys(defs).forEach((type) => {
        if (importsRegistry[type]) {
            log_1.warn(`Overwriting duplicated type '${type}' ${importsRegistry[type]} -> ${lib}`);
        }
        importsRegistry[type] = lib;
    });
}
