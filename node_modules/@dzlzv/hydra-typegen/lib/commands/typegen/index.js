"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const metadata_1 = require("../../metadata/metadata");
const metadata_2 = require("../../metadata");
const generators_1 = require("../../generators");
const parse_yaml_1 = require("../../helpers/parse-yaml");
const debug = debug_1.default('hydra-typegen:typegen');
class Typegen extends command_1.Command {
    async run() {
        const { flags, args } = this.parse(Typegen);
        if (flags.debug) {
            debug_1.default.enable('hydra-typegen:*');
        }
        let config;
        if (args.config) {
            config = parse_yaml_1.parseConfigFile(path_1.default.resolve(args.config));
        }
        else {
            config = this.parseFlags(flags);
        }
        await this.generate(config);
    }
    parseFlags(flags) {
        let customTypes;
        if (flags.typedefs) {
            if (flags.typelib === undefined) {
                throw new Error(`Please specify the library with type definitions with --typelib`);
            }
            customTypes = {
                lib: flags.typelib,
                typedefsLoc: path_1.default.resolve(flags.typedefs),
            };
        }
        const events = flags.events
            ? flags.events.split(',').map((e) => e.trim())
            : [];
        const calls = flags.calls
            ? flags.calls.split(',').map((c) => c.trim())
            : [];
        if (events.length === 0 && calls.length === 0) {
            throw new Error(`Nothing to generate: at least one event or call should be provided.`);
        }
        return {
            events,
            calls,
            outDir: flags.outDir,
            metadata: {
                source: flags.metadata,
                blockHash: flags.blockHash,
            },
            strict: flags.strict,
            customTypes,
        };
    }
    async buildGeneratorConfig(config) {
        const { outDir, customTypes } = config;
        if (customTypes) {
            metadata_1.registerCustomTypes(customTypes.typedefsLoc);
        }
        const modules = await metadata_2.extractMeta(config);
        return {
            customTypes,
            importsRegistry: generators_1.buildImportsRegistry(customTypes),
            modules,
            validateArgs: config.strict || false,
            dest: path_1.default.resolve(outDir),
        };
    }
    async generate(config) {
        const generatorConfig = await this.buildGeneratorConfig(config);
        const { dest } = generatorConfig;
        debug(`Output dir: ${dest}`);
        fs_1.default.mkdirSync(dest, { recursive: true });
        generators_1.generateModuleTypes(generatorConfig);
        generators_1.generateIndex(generatorConfig);
    }
}
exports.default = Typegen;
Typegen.description = `Generate Typescript classes for the Substrate events`;
Typegen.usage = 'typegen Balances.transfer,Treasury.depositCreated';
Typegen.args = [
    {
        name: 'config',
        optional: true,
        description: `Path to YML config file`,
    },
];
Typegen.flags = {
    events: command_1.flags.string({
        char: 'e',
        description: `Comma-separated list of substrate events in the formation <module>.<name>`,
    }),
    calls: command_1.flags.string({
        char: 'c',
        description: `Comma-separated list of substrate calls in the format <module>.<name>`,
    }),
    metadata: command_1.flags.string({
        char: 'm',
        description: `Chain metadata source. \
If starts with ws:// or wss:// the metadata is pulled by an RPC call to the provided endpoint. \
Otherwise a relative path to a json file matching the RPC call response is expected`,
        default: 'metadata.json',
    }),
    blockHash: command_1.flags.string({
        char: 'h',
        description: 'Hash of the block from which the metadata will be fetched. Only applied if metadata is pulled via an RPC call',
    }),
    typedefs: command_1.flags.string({
        char: 't',
        description: 'A relative path to a file with JSON definitions for custom types used by the chain',
    }),
    typelib: command_1.flags.string({
        char: 'i',
        description: `A JavaScript module from which the custom types should be imported, e.g. '@joystream/types/augment'`,
    }),
    outDir: command_1.flags.string({
        char: 'o',
        description: 'A relative path the root folder where the generated files will be generated',
        default: 'generated/types',
    }),
    strict: command_1.flags.boolean({
        char: 's',
        description: `Strict mode. If on, the generated code throws an error if the input event argument \
types don't much the metadata definiton`,
        allowNo: true,
        default: false,
    }),
    debug: command_1.flags.boolean({
        description: `Output debug info`,
        char: 'd',
        default: false,
    }),
};
