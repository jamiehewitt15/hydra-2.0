"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.withDependenciesResolutions = void 0;
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const utils_1 = require("../utils/utils");
const select = require("@inquirer/select");
const input = require("@inquirer/input");
const password = require("@inquirer/password");
const glob = require("glob");
const debug = debug_1.default('qnode-cli:scaffold');
// TODO: fetch from a well-known source?
const INDEXERS = [
    {
        name: 'local',
        value: 'localhost',
        description: 'Self-hosted indexer at localhost:4000',
        url: 'http://localhost:4001/graphql',
    },
    {
        name: 'subsocial',
        value: 'subsocial',
        description: 'Ready-to use indexer of Subsocial, hosted by Joystream',
        url: 'https://subsocial-indexer.joystream.app/graphql',
    },
    {
        name: 'other',
        value: 'other',
        description: 'Skip for now, I will manually set INDEXER_ENDPOINT_URL later on',
        url: '',
    },
];
class Scaffold extends command_1.Command {
    async run() {
        const { flags } = this.parse(Scaffold);
        debug(`Flags: ${JSON.stringify(flags, null, 2)}`);
        let ctx = {};
        if (flags.silent) {
            ctx = Object.assign(Object.assign({}, flags), { dbName: flags.name });
        }
        else {
            ctx = await this.promptDotEnv();
        }
        ctx = withDependenciesResolutions(ctx);
        cli_ux_1.default.action.start('Scaffolding');
        const destRoot = path.resolve(flags.dir);
        utils_1.createDir(destRoot, flags.rewrite, true);
        debug(`Writing files to ${destRoot}`);
        const templatesRoot = path.resolve(__dirname, '..', 'templates', 'scaffold');
        glob('**/*', { cwd: templatesRoot, dot: true }, (error, files) => {
            if (error) {
                throw new Error(`An error occured during scaffolding: ${error.message}`);
            }
            files.forEach((sourceFile) => {
                let destPath = path.join(destRoot, sourceFile);
                const sourcePath = path.join(templatesRoot, sourceFile);
                if (fs.lstatSync(sourcePath).isDirectory()) {
                    utils_1.createDir(destPath);
                    return;
                }
                debug(`Writing ${destPath}`);
                const source = fs.readFileSync(sourcePath, 'utf-8');
                if (sourcePath.endsWith('.mst')) {
                    // if it's a template, use the context
                    destPath = destPath.slice(0, -4);
                    fs.writeFileSync(destPath, mustache_1.default.render(source, ctx));
                }
                else {
                    fs.writeFileSync(destPath, source);
                }
            });
        });
        cli_ux_1.default.action.stop();
    }
    async dotenvFromFlags(flags) {
        const template = await fs.readFile(utils_1.getTemplatePath('scaffold/.env'), 'utf-8');
        return mustache_1.default.render(template, Object.assign(Object.assign({}, flags), { dbName: flags.projectName }));
    }
    async promptDotEnv() {
        let ctx = {};
        const projectName = (await input({
            message: 'Enter your project name',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { projectName });
        ctx = Object.assign(Object.assign({}, ctx), (await this.promptIndexerURL(ctx)));
        const dbName = (await input({
            message: 'Database name',
            default: projectName,
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbName });
        const dbHost = (await input({
            message: 'Database host',
            default: 'localhost',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbHost });
        const dbPort = (await input({
            message: 'Database port',
            default: '5432',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbPort });
        const dbUser = (await input({
            message: 'Database user',
            default: 'postgres',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbUser });
        const dbPassword = (await password({
            message: 'Database user password',
            type: 'mask',
            default: 'postgres',
        }));
        ctx = Object.assign(Object.assign({}, ctx), { dbPassword });
        return ctx;
    }
    async promptIndexerURL(ctx) {
        const answer = await select({
            message: 'Select a Hydra Indexer to be used by the mappings processor',
            choices: INDEXERS,
        });
        ctx = Object.assign(Object.assign({}, ctx), { indexerUrl: answer.url });
        return ctx;
    }
}
exports.default = Scaffold;
Scaffold.description = `Starter kit: generates a directory layout and a sample schema file`;
Scaffold.flags = {
    name: command_1.flags.string({
        char: 'n',
        description: 'Project name',
        default: 'hydra-scaffold',
    }),
    indexerUrl: command_1.flags.string({
        char: 'i',
        description: 'Hydra Indexer endpoint',
        default: (_a = INDEXERS.find((e) => e.name === 'polkadot')) === null || _a === void 0 ? void 0 : _a.url,
    }),
    dir: command_1.flags.string({
        char: 'd',
        description: 'Project folder',
        default: process.cwd(),
    }),
    rewrite: command_1.flags.boolean({
        description: 'Clear the folder before scaffolding',
    }),
    silent: command_1.flags.boolean({
        description: 'If present, the scaffolder is non-interactive and uses only provided CLI flags',
    }),
    // pass --no-mappings to skip default mappings and schema
    mappings: command_1.flags.boolean({
        char: 'm',
        allowNo: true,
        description: 'Create schema and mappings',
        default: true,
    }),
    blockHeight: command_1.flags.string({
        char: 'b',
        description: 'Start block height',
        default: '0',
    }),
    dbHost: command_1.flags.string({
        char: 'h',
        description: 'Database host',
        default: 'localhost',
    }),
    dbPort: command_1.flags.string({
        char: 'p',
        description: 'Database port',
        default: '5432',
    }),
    dbUser: command_1.flags.string({
        char: 'u',
        description: 'Database user',
        default: 'postgres',
    }),
    dbPassword: command_1.flags.string({
        char: 'x',
        description: 'Database user password',
        default: 'postgres',
    }),
    appPort: command_1.flags.string({
        char: 'a',
        description: 'GraphQL server port',
        default: '4000',
    }),
};
function withDependenciesResolutions(ctx) {
    return Object.assign(Object.assign({}, ctx), { hydraVersion: process.env.HYDRA_CLI_VERSION ||
            utils_1.resolvePackageVersion('@dzlzv/hydra-cli'), hydraCommonVersion: utils_1.resolvePackageVersion('@dzlzv/hydra-common'), hydraDbUtilsVersion: utils_1.resolvePackageVersion('@dzlzv/hydra-db-utils'), hydraProcessorVersion: utils_1.resolvePackageVersion('@dzlzv/hydra-processor'), hydraTypegenVersion: utils_1.resolvePackageVersion('@dzlzv/hydra-typegen'), hydraWarthogVersion: utils_1.getWarthogDependency() });
}
exports.withDependenciesResolutions = withDependenciesResolutions;
