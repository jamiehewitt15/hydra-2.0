"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const start_1 = require("../start");
const log_1 = require("../util/log");
const dotenv_1 = tslib_1.__importDefault(require("dotenv"));
const hydra_common_1 = require("@dzlzv/hydra-common");
class Run extends command_1.Command {
    async run() {
        log_1.info('Starting Hydra Processor');
        const { flags } = this.parse(Run);
        if (flags.env) {
            dotenv_1.default.config({ path: flags.env });
        }
        if (flags.indexer) {
            process.env.INDEXER_ENDPOINT_URL = flags.indexer;
        }
        if (flags.manifest) {
            process.env.MANIFEST_PATH = flags.manifest;
        }
        if (flags.id) {
            process.env.ID = flags.id;
        }
        const processor = new start_1.ProcessorRunner();
        try {
            await processor.process();
        }
        catch (e) {
            log_1.error(`${hydra_common_1.logError(e)}`);
            process.exitCode = 1;
        }
        finally {
            log_1.info(`Shutting down...`);
            await processor.shutDown();
        }
    }
}
exports.default = Run;
Run.flags = {
    manifest: command_1.flags.string({
        char: 'm',
        description: 'Manifest file',
    }),
    indexer: command_1.flags.string({
        description: 'Indexer URL to source events',
    }),
    env: command_1.flags.string({
        char: 'e',
        description: 'Path to a file with environment variables',
    }),
    id: command_1.flags.string({
        description: 'ID of the processor (useful for multi-processor setups)',
    }),
};
//# sourceMappingURL=run.js.map