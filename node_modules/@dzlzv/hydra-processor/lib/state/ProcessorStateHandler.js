"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initState = exports.ProcessorStateHandler = void 0;
const tslib_1 = require("tslib");
const dal_1 = require("../db/dal");
const entities_1 = require("../entities");
const typeorm_1 = require("typeorm");
const debug_1 = tslib_1.__importDefault(require("debug"));
const events_1 = require("../start/events");
const config_1 = require("../start/config");
const assert = require("assert");
const debug = debug_1.default('index-builder:processor-state-handler');
class ProcessorStateHandler {
    async persist(state, em) {
        assert(state.lastProcessedEvent, 'Cannot persist undefined event ID');
        const processed = new entities_1.ProcessedEventsLogEntity();
        processed.processor = config_1.conf.ID;
        processed.eventId = state.lastProcessedEvent;
        processed.lastScannedBlock = state.lastScannedBlock;
        const repository = em
            ? em.getRepository('ProcessedEventsLogEntity')
            : typeorm_1.getRepository('ProcessedEventsLogEntity');
        await repository.save(processed);
        events_1.eventEmitter.emit(events_1.STATE_CHANGE, state);
    }
    async init(blockInterval) {
        const lastState = await dal_1.loadState(config_1.conf.ID);
        const state = initState(blockInterval, lastState);
        events_1.eventEmitter.emit(events_1.STATE_CHANGE, state);
        return state;
    }
}
exports.ProcessorStateHandler = ProcessorStateHandler;
function initState(blockInterval, lastState) {
    let atBlock = 0;
    if (blockInterval) {
        debug(`Mappings will be applied to block interval: ${JSON.stringify(blockInterval)}`);
        atBlock = blockInterval.from || 0;
    }
    if (atBlock > 0) {
        debug(`Got block height hint: ${atBlock}`);
    }
    if (lastState) {
        debug(`Found the most recent processed event ${lastState.eventId}`);
        if (atBlock > lastState.lastScannedBlock) {
            debug(`WARNING! There are processed events in the processor logs.
          Last processed event id ${lastState.eventId}. The indexer 
          will continue from block ${lastState.lastScannedBlock} and ignore the block height hint.`);
        }
        return {
            lastProcessedEvent: lastState.eventId,
            lastScannedBlock: lastState.lastScannedBlock,
        };
    }
    return {
        lastScannedBlock: atBlock,
        lastProcessedEvent: undefined,
    };
}
exports.initState = initState;
//# sourceMappingURL=ProcessorStateHandler.js.map