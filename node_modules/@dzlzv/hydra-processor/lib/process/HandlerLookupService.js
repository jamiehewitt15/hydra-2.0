"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveArgType = exports.resolveImports = exports.HandlerLookupService = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-explicit-any  */
const debug_1 = tslib_1.__importDefault(require("debug"));
const config_1 = require("../start/config");
const manifest_1 = require("../start/manifest");
const debug = debug_1.default('hydra-processor:handler-lookup-service');
const EXTRINSIC_EVENTS = ['system.ExtrinsicSuccess'];
class HandlerLookupService {
    constructor(mappings = config_1.getManifest().mappings) {
        this.mappings = mappings;
        this.argFactory = {};
        this.events = Object.keys(this.mappings.eventHandlers);
        debug(`The following events will be processed: ${JSON.stringify(this.events, null, 2)}`);
        debug(`The following extrinsics will be processed: ${JSON.stringify(Object.keys(this.mappings.extrinsicHandlers), null, 2)}`);
        this.argFactory[manifest_1.CONTEXT_CLASS_NAME] = ({ context }) => context;
        this.argFactory[manifest_1.STORE_CLASS_NAME] = ({ dbStore }) => dbStore;
    }
    async load() {
        const resolvedImports = await resolveImports(this.mappings.imports);
        const handlers = [
            ...Object.values(this.mappings.eventHandlers),
            ...Object.values(this.mappings.extrinsicHandlers),
        ];
        handlers.forEach((h) => {
            h.argTypes.forEach((argType) => {
                if (!this.argFactory[argType]) {
                    const proto = resolveArgType(argType, resolvedImports).prototype;
                    this.argFactory[argType] = ({ context }) => {
                        const instance = Object.create(proto);
                        return new instance.constructor(context);
                    };
                }
            });
        });
    }
    eventsToHandle() {
        return this.events;
    }
    async lookupAndCall(ctxArgs) {
        const { handlerFunc, argTypes } = this.lookupHander(ctxArgs);
        const args = argTypes
            ? argTypes.map((a) => this.argFactory[a](ctxArgs))
            : [];
        await handlerFunc(...args);
    }
    lookupHander({ context }) {
        let handler;
        if (EXTRINSIC_EVENTS.includes(context.name)) {
            if (context.extrinsic === undefined) {
                throw new Error(`No extrinsics found in the context ${JSON.stringify(context, null, 2)}`);
            }
            const extrinsicName = `${context.extrinsic.section}.${context.extrinsic.method}`;
            handler = this.mappings.extrinsicHandlers[extrinsicName];
        }
        else {
            handler = this.mappings.eventHandlers[context.name];
        }
        if (handler === undefined) {
            throw new Error(`Cannot find a handler for the execution context ${JSON.stringify(context, null, 2)}`);
        }
        return handler;
    }
}
exports.HandlerLookupService = HandlerLookupService;
async function resolveImports(imports) {
    let resolved = {};
    for (const importPath of imports) {
        const resolvedImport = await Promise.resolve().then(() => tslib_1.__importStar(require(importPath)));
        resolved = Object.assign(Object.assign({}, resolvedImport), resolved);
    }
    return resolved;
}
exports.resolveImports = resolveImports;
function resolveArgType(argType, imports) {
    const modules = argType.split('.').map((s) => s.trim());
    let obj = imports;
    for (const module of modules) {
        obj = obj[module];
        if (obj === undefined) {
            throw new Error(`Cannot load type ${argType}:${module}`);
        }
    }
    return obj;
}
exports.resolveArgType = resolveArgType;
//# sourceMappingURL=HandlerLookupService.js.map