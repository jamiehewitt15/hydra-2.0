"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nextEventQueries = exports.processEvent = exports.nextState = exports.MappingsProcessor = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/naming-convention */
const hydra_db_utils_1 = require("@dzlzv/hydra-db-utils");
const ingest_1 = require("../ingest");
const HandlerLookupService_1 = require("./HandlerLookupService");
const typeorm_1 = require("typeorm");
const hydra_common_1 = require("@dzlzv/hydra-common");
const delay_1 = tslib_1.__importDefault(require("delay"));
const p_wait_for_1 = tslib_1.__importDefault(require("p-wait-for"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const state_1 = require("../state");
const config_1 = require("../start/config");
const events_1 = require("../start/events");
const log_1 = require("../util/log");
const utils_1 = require("../util/utils");
const debug = debug_1.default('hydra-processor:mappings-processor');
class MappingsProcessor {
    constructor(eventsSource = new ingest_1.GraphQLSource(), handlerLookup = new HandlerLookupService_1.HandlerLookupService(), stateHandler = new state_1.ProcessorStateHandler(), mappings = config_1.getManifest().mappings) {
        this.eventsSource = eventsSource;
        this.handlerLookup = handlerLookup;
        this.stateHandler = stateHandler;
        this.mappings = mappings;
        this._started = false;
        this.globalFilterConfig = {
            blockInterval: mappings.blockInterval,
            events: Object.keys(mappings.eventHandlers),
            extrinsics: Object.keys(mappings.extrinsicHandlers),
            blockWindow: config_1.conf.BLOCK_WINDOW,
        };
    }
    async start() {
        log_1.info('Starting the processor');
        this._started = true;
        this.state = await this.stateHandler.init();
        await this.handlerLookup.load();
        await p_wait_for_1.default(async () => {
            log_1.info(`Waiting for the indexer head to be initialized`);
            this.indexerHead = await this.eventsSource.indexerHead();
            return this.indexerHead >= 0;
        });
        await Promise.all([this.pollIndexer(), this.processingLoop()]);
    }
    stop() {
        this._started = false;
    }
    get stopped() {
        return !this._started;
    }
    async pollIndexer() {
        // TODO: uncomment this block when eventSource will emit
        // this.eventsSource.on('NewIndexerHead', (h: number) => {
        //   debug(`New Indexer Head: ${h}`)
        //   this.indexerHead = h
        // });
        // For now, simply update indexerHead regularly
        while (this._started) {
            this.indexerHead = await this.eventsSource.indexerHead();
            await delay_1.default(config_1.conf.POLL_INTERVAL_MS);
        }
    }
    async awaitIndexer() {
        debug(`Indexer Head: ${this.indexerHead} Last Scanned Block: ${this.state.lastScannedBlock}`);
        // here we should eventually listen only to the events
        // For now, we simply wait until the indexer go for at least {MINIMUM_BLOCKS_AHEAD}
        // blocks ahead of the last scanned block
        await p_wait_for_1.default(() => !this._started ||
            this.indexerHead - this.state.lastScannedBlock > config_1.conf.MIN_BLOCKS_AHEAD);
    }
    // Long running loop where events are fetched and the mappings are applied
    async processingLoop() {
        while (this.shouldWork()) {
            try {
                await this.awaitIndexer();
                const queries = nextEventQueries(this);
                const events = await this.eventsSource.nextBatch(queries, config_1.conf.BATCH_SIZE);
                debug(`Processing new batch of events of size: ${events.length}`);
                for (const event of events) {
                    await typeorm_1.getConnection().transaction(async (manager) => {
                        this.state = await processEvent(event, () => this.handlerLookup.lookupAndCall({
                            dbStore: hydra_db_utils_1.makeDatabaseManager(manager),
                            context: event,
                        }));
                        await this.stateHandler.persist(this.state, manager);
                    });
                    events_1.eventEmitter.emit(events_1.PROCESSED_EVENT, event);
                }
                // Even if there were no events, update the last scanned block
                this.state = nextState(this.state, queries);
                await this.stateHandler.persist(this.state);
            }
            catch (e) {
                log_1.error(`Stopping the proccessor due to errors: ${hydra_common_1.logError(e)}`);
                this.stop();
                throw new Error(e);
            }
        }
        debug(`The processor has stopped at state: ${JSON.stringify(this.state, null, 2)}`);
    }
    shouldWork() {
        return (this._started &&
            this.state.lastScannedBlock <= this.globalFilterConfig.blockInterval.to);
    }
}
exports.MappingsProcessor = MappingsProcessor;
function nextState(state, filter) {
    const lastProcessedEvent = state.lastProcessedEvent || hydra_common_1.formatEventId(0, 0);
    const { blockHeight } = utils_1.parseEventId(lastProcessedEvent);
    return {
        lastScannedBlock: Math.min(...filter.map((f) => f.block_lte), blockHeight),
        lastProcessedEvent,
    };
}
exports.nextState = nextState;
async function processEvent(event, handler) {
    debug(`Processing event ${event.id}`);
    debug(`JSON: ${JSON.stringify(event, null, 2)}`);
    await handler();
    debug(`Event ${event.id} done`);
    return {
        lastProcessedEvent: event.id,
        lastScannedBlock: event.blockNumber,
    };
}
exports.processEvent = processEvent;
function nextEventQueries(context) {
    const { state, indexerHead, globalFilterConfig } = context;
    const { blockInterval, events, extrinsics, blockWindow } = globalFilterConfig;
    const globalBlock = {
        id_gt: state.lastProcessedEvent,
        block_gte: Math.max(state.lastScannedBlock, blockInterval.from),
        block_lte: Math.min(state.lastScannedBlock + blockWindow, indexerHead, blockInterval.to),
    };
    return [
        Object.assign(Object.assign({}, globalBlock), { events }),
        Object.assign(Object.assign({}, globalBlock), { events: ['system.ExtrinsicSuccess'], // TODO: make success-only configurable
            extrinsics }),
    ];
}
exports.nextEventQueries = nextEventQueries;
//# sourceMappingURL=MappingsProcessor.js.map