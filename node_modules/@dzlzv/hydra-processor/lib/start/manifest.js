"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseBlockInterval = exports.inferDefault = exports.validateArgTypes = exports.parseHandlerDef = exports.parseManifest = exports.CALL_SUFFIX = exports.EVENT_SUFFIX = exports.CONTEXT_CLASS_NAME = exports.STORE_CLASS_NAME = void 0;
const tslib_1 = require("tslib");
const yaml_1 = tslib_1.__importDefault(require("yaml"));
const yaml_validator_1 = tslib_1.__importDefault(require("yaml-validator"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const lodash_1 = require("lodash");
const utils_1 = require("../util/utils");
const log_1 = require("../util/log");
exports.STORE_CLASS_NAME = 'DatabaseManager';
exports.CONTEXT_CLASS_NAME = 'SubstrateEvent';
exports.EVENT_SUFFIX = 'Event';
exports.CALL_SUFFIX = 'Call';
const manifestValidatorOptions = {
    structure: {
        version: 'string',
        'description?': 'string',
        'repository?': 'string',
        dataSource: {
            kind: 'string',
            chain: 'string',
            indexerVersion: 'string',
        },
        entities: ['string'],
        mappings: {
            hydraCommonVersion: 'string',
            mappingsModule: 'string',
            'imports?': ['string'],
            'blockInterval?': 'string',
            'eventHandlers?': [
                {
                    event: 'string',
                    'handler?': 'string',
                },
            ],
            'extrinsicHandlers?': [
                {
                    extrinsic: 'string',
                    'handler?': 'string',
                    'success?': 'boolean',
                },
            ],
            'preBlockHooks?': ['string'],
            'postBlockHooks?': ['string'],
        },
    },
    onWarning: function (error, filepath) {
        throw new Error(`${filepath} has error: ${JSON.stringify(error)}`);
    },
};
function parseManifest(manifestLoc) {
    const validator = new yaml_validator_1.default(manifestValidatorOptions);
    validator.validate([manifestLoc]);
    if (validator.report()) {
        throw new Error(`Failed to load the manifest file at location ${manifestLoc}: ${validator.logs.join('\n')}`);
    }
    const parsed = yaml_1.default.parse(fs_1.default.readFileSync(manifestLoc, 'utf8'));
    const { mappings, entities } = parsed;
    validate(mappings);
    return Object.assign(Object.assign({}, parsed), { entities: entities.map((e) => path_1.default.resolve(e.trim())), mappings: inferDefaults(mappings) });
}
exports.parseManifest = parseManifest;
function validate(parsed) {
    if (parsed.eventHandlers === undefined &&
        parsed.extrinsicHandlers === undefined) {
        throw new Error(`At least one event or extrinsic handler must be defined`);
    }
    const oursHydraCommonVersion = utils_1.resolvePackageVersion('@dzlzv/hydra-common');
    if (!semver_1.default.satisfies(parsed.hydraCommonVersion, oursHydraCommonVersion)) {
        throw new Error(`The hydra-common version ${parsed.hydraCommonVersion} does \\
not satisfy the version of the processor (${oursHydraCommonVersion})`);
    }
}
function inferDefaults(parsed) {
    const { hydraCommonVersion, mappingsModule, blockInterval, eventHandlers, extrinsicHandlers, preBlockHooks, postBlockHooks, imports, } = parsed;
    if (mappingsModule === undefined) {
        throw new Error(`Cannot resolve mappings module ${mappingsModule}`);
    }
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const resolvedModule = require(path_1.default.resolve(mappingsModule));
    const parseHandler = function (def) {
        const { input, handler, suffix } = def;
        const { name, argTypes } = handler
            ? parseHandlerDef(handler)
            : inferDefault(input || '', suffix);
        return {
            argTypes,
            handlerFunc: resolveHandler(resolvedModule, name),
        };
    };
    return {
        hydraCommonVersion,
        mappingsModule: resolvedModule,
        imports: [mappingsModule, ...(imports || [])].map((p) => path_1.default.resolve(p)),
        blockInterval: parseBlockInterval(blockInterval),
        eventHandlers: eventHandlers
            ? eventHandlers.reduce((acc, item) => {
                acc[item.event] = parseHandler(Object.assign(Object.assign({}, item), { input: item.event, suffix: exports.EVENT_SUFFIX }));
                return acc;
            }, {})
            : {},
        extrinsicHandlers: extrinsicHandlers
            ? extrinsicHandlers.reduce((acc, item) => {
                acc[item.extrinsic] = Object.assign({ success: item.success || true }, parseHandler(Object.assign(Object.assign({}, item), { input: item.extrinsic, suffix: exports.CALL_SUFFIX })));
                return acc;
            }, {})
            : {},
        preBlockHooks: preBlockHooks
            ? preBlockHooks.map((handler) => parseHandler({ handler }))
            : [],
        postBlockHooks: postBlockHooks
            ? postBlockHooks.map((handler) => parseHandler({ handler }))
            : [],
    };
}
function parseHandlerDef(handler) {
    // eslint-disable-next-line no-useless-escape
    const split = handler.split(/[\(\)]/).map((s) => s.trim());
    // name(arg1, arg2, arg3) -> ["name", "arg1,arg2,arg3"]
    if (split.length !== 3) {
        throw new Error(`The mapping handler definition ${handler} does not match the pattern "name(type1, type2, ...)`);
    }
    const name = split[0];
    const argTypes = lodash_1.compact(split[1].split(/,/).map((s) => s.trim())); // remove empty
    validateArgTypes({ handler, argTypes });
    return { name, argTypes };
}
exports.parseHandlerDef = parseHandlerDef;
function validateArgTypes({ handler, argTypes, }) {
    if (argTypes.length === 0) {
        log_1.warn(`Handler ${handler} has no arguments`);
        return;
    }
    const typeOccurrences = lodash_1.countBy(argTypes);
    if (!typeOccurrences[exports.STORE_CLASS_NAME]) {
        log_1.warn(`Handler ${handler} does not have an argument of type ${exports.STORE_CLASS_NAME}`);
    }
    if (typeOccurrences[exports.STORE_CLASS_NAME] &&
        typeOccurrences[exports.STORE_CLASS_NAME] > 1) {
        throw new Error(`Handler ${handler} has multiple arguments of type ${exports.STORE_CLASS_NAME}`);
    }
    const eventTypeCnt = argTypes.reduce((acc, item) => (lodash_1.endsWith(item, exports.EVENT_SUFFIX) ? acc + 1 : acc), 0);
    if (eventTypeCnt > 1) {
        throw new Error(`Handler ${handler} has multiple arguments of event type`);
    }
    const callTypeCnt = argTypes.reduce((acc, item) => (lodash_1.endsWith(item, exports.CALL_SUFFIX) ? acc + 1 : acc), 0);
    if (callTypeCnt > 1) {
        throw new Error(`Handler ${handler} has multiple arguments of call type`);
    }
}
exports.validateArgTypes = validateArgTypes;
function inferDefault(input, suffix) {
    const [module, name] = input.split('.').map((s) => s.trim());
    return {
        name: `${lodash_1.camelCase(module)}_${name}${suffix || ''}`,
        argTypes: [exports.STORE_CLASS_NAME, `${module}.${name}${suffix || ''}`],
    };
}
exports.inferDefault = inferDefault;
function resolveHandler(mappingsModule, name) {
    if (mappingsModule[name] === undefined ||
        typeof mappingsModule[name] !== 'function') {
        throw new Error(`Cannot resolve the handler ${name} in the mappings module`);
    }
    return mappingsModule[name];
}
function parseBlockInterval(blockInterval) {
    if (blockInterval === undefined) {
        return {
            from: 0,
            to: Number.MAX_SAFE_INTEGER,
        };
    }
    // accepted formats:
    //   [1,2]
    //   [,2]
    //   [2,]
    // eslint-disable-next-line no-useless-escape
    const parts = blockInterval.split(/[\[,\]]/).map((part) => part.trim());
    if (parts.length !== 4) {
        throw new Error(`Block interval ${blockInterval} does not match the expected format [number?, number?]`);
    }
    // the parts array must be in the form ["", from, to, ""]
    const from = parts[1].length > 0 ? Number.parseInt(parts[1]) : 0;
    const to = parts[2].length > 0 ? Number.parseInt(parts[2]) : Number.MAX_SAFE_INTEGER;
    return { from, to };
}
exports.parseBlockInterval = parseBlockInterval;
//# sourceMappingURL=manifest.js.map