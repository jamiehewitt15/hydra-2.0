"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEventsGraphQLQuery = exports.collectQueries = exports.GraphQLSource = void 0;
const tslib_1 = require("tslib");
const graphql_request_1 = require("graphql-request");
const debug_1 = tslib_1.__importDefault(require("debug"));
const config_1 = require("../start/config");
const utils_1 = require("../util/utils");
const debug = debug_1.default('index-builder:processor');
// const GET_EVENTS_AFTER_QUERY = `
// query GetEventsAfterID( $afterID: ID, $events: [String!]!, $fromBlock: Int, $toBlock: Int, $size: Int) {
//   substrateEventsAfter(where: { name_in: $events, $blockNumber_gte: $fromBlock, blockNumber_lte: $toBlock }, afterID: $afterID, limit: $size) {
//     id
//     name
//     method
//     params {
//       name
//       type
//       value
//     }
//     index
//     blockNumber
//     blockTimestamp
//     extrinsic {
//       method
//       section
//       versionInfo
//       signer
//       args
//       signature
//       hash
//       tip
//     }
//   }
// }
// `
// to be replaced with a ws subsription
const GET_INDEXER_HEAD = `
query {
  indexerStatus {
    head
  }
}
`;
class GraphQLSource {
    constructor() {
        const _endpoint = config_1.conf.INDEXER_ENDPOINT_URL;
        debug(`Using Indexer API endpoint ${_endpoint}`);
        this.graphClient = new graphql_request_1.GraphQLClient(_endpoint);
    }
    // TODO: implement
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    subscribe(events) {
        throw new Error('Method not implemented.');
    }
    async indexerHead() {
        const status = await this.graphClient.request(GET_INDEXER_HEAD);
        return status.indexerStatus.head;
    }
    async nextBatch(queries, size) {
        const query = collectQueries(queries.map((f) => getEventsGraphQLQuery(f, size)));
        debug(`GraphqQL Query: ${query}`);
        const raw = await this.graphClient.request(query);
        const data = Object.keys(raw)
            .reduce((acc, key) => [...acc, ...raw[key]], [])
            .sort((a, b) => (a.id < b.id ? -1 : 1));
        debug(`Fetched ${data.length} events`);
        debug(`Events: ${JSON.stringify(data, null, 2)} events`);
        return data;
    }
}
exports.GraphQLSource = GraphQLSource;
function collectQueries(queries) {
    // we need to do this hack to be able to run multiple queries in a single request
    return `query {
    ${queries.map((q, i) => `query${i}: ${q}`).join('\n')}
  }`;
}
exports.collectQueries = collectQueries;
function getEventsGraphQLQuery({ events, extrinsics, block_gte, block_lte, id_gt }, limit) {
    const eventsFilter = events.length > 0 ? `name_in: [${utils_1.quotedJoin(events)}],` : '';
    const extrinsicsFilter = extrinsics && extrinsics.length > 0
        ? `extrinsicName_in: [${utils_1.quotedJoin(extrinsics)}],`
        : '';
    const idFilter = id_gt ? `afterID: "${id_gt}",` : '';
    return `
  substrateEventsAfter(where: { ${eventsFilter}${extrinsicsFilter} blockNumber_gte: ${block_gte}, blockNumber_lte: ${block_lte} }, ${idFilter} limit: ${limit}) {
    id
    name 
    method 
    params {
      name
      type
      value
    }
    index 
    blockNumber
    blockTimestamp
    extrinsic {
      method
      section
      versionInfo
      signer
      args
      signature
      hash
      tip
    }
  }
`;
}
exports.getEventsGraphQLQuery = getEventsGraphQLQuery;
//# sourceMappingURL=GraphQLSource.js.map